import java.util.Comparator;

import components.map.Map;
import components.map.Map.Pair;
import components.map.Map1L;
import components.queue.Queue;
import components.queue.Queue1L;
import components.set.Set;
import components.set.Set1L;
import components.simplereader.SimpleReader;
import components.simplereader.SimpleReader1L;
import components.simplewriter.SimpleWriter;
import components.simplewriter.SimpleWriter1L;

/**
 * A program that will take a .txt file as an input and output a .html file
 * containing a list of all words in the .txt file and how many times each word
 * occurs.
 *
 * @author Mason Rocco
 */
public final class WordCounter {

    /**
     * Default constructor--private to prevent instantiation.
     */
    private WordCounter() {
    }

    /**
     * Comparator class to override compare method.
     */
    private static class Compare implements Comparator<String> {
        @Override
        public int compare(String s1, String s2) {
            return s1.toLowerCase().compareTo(s2.toLowerCase());
        }
    }

    /**
     * Outputs the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * @param out
     *            the output stream
     * @param fileName
     *            the name of the file
     * @updates out.content
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    private static void outputIndexHeader(SimpleWriter out, String fileName) {
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";
        out.println("<html><head><title>Words Counted in");
        out.println(fileName + "</title>");
        out.println("</head>");
        out.println("<body>");
        out.println("<h2>Words Counted in");
        out.println(fileName + "</h2><hr/>");
        out.println("<table border=\"1\">");
        out.println("<tr><th>Words</th>");
        out.println("<th>Counts</th>");
        out.println("</tr>");
    }

    /**
     * Outputs the "closing" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * @param out
     *            the output stream
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     *
     */
    private static void outputIndexFooter(SimpleWriter out) {
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";

        out.println("</table>");
        out.println("</body>");
        out.println("</html>");
    }

    /**
     * Generates the set of characters in the given {@code String} into the
     * given {@code Set}.
     *
     * @param str
     *            the given {@code String}
     * @param strSet
     *            the {@code Set} to be replaced
     * @replaces strSet
     * @ensures strSet = entries(str)
     */
    private static void generateElements(String str, Set<Character> strSet) {
        assert str != null : "Violation of: str is not null";
        assert strSet != null : "Violation of: strSet is not null";
        for (int i = 0; i < str.length(); i++) {
            char character = str.charAt(i);
            boolean isSubset = strSet.contains(character);
            if (!isSubset) {
                strSet.add(character);
            }

        }

    }

    /**
     * Returns the first "word" (maximal length string of characters not in
     * {@code separators}) or "separator string" (maximal length string of
     * characters in {@code separators}) in the given {@code text} starting at
     * the given {@code position}.
     *
     * @param text
     *            the {@code String} from which to get the word or separator
     *            string
     * @param position
     *            the starting index
     * @param separators
     *            the {@code Set} of separator characters
     * @return the first word or separator string found in {@code text} starting
     *         at index {@code position}
     * @requires 0 <= position < |text|
     * @ensures <pre>
     * nextWordOrSeparator =
     *   text[position, position + |nextWordOrSeparator|)  and
     * if entries(text[position, position + 1)) intersection separators = {}
     * then
     *   entries(nextWordOrSeparator) intersection separators = {}  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      intersection separators /= {})
     * else
     *   entries(nextWordOrSeparator) is subset of separators  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      is not subset of separators)
     * </pre>
     */
    private static String nextWordOrSeparator(String text, int position,
            Set<Character> separators) {
        assert text != null : "Violation of: text is not null";
        assert separators != null : "Violation of: separators is not null";
        assert 0 <= position : "Violation of: 0 <= position";
        assert position < text.length() : "Violation of: position < |text|";

        char first = text.charAt(position);
        String nextWordOrSeparator = "";
        int i = position + 1;
        nextWordOrSeparator = nextWordOrSeparator + first;
        if (!separators.contains(first)) {
            while (i < text.length() && !separators.contains(first)) {
                first = text.charAt(i);
                if (!separators.contains(first)) {
                    String concat = "" + first;
                    nextWordOrSeparator = nextWordOrSeparator.concat(concat);
                }
                i++;
            }

        } else {
            while (i < text.length() && separators.contains(first)) {
                first = text.charAt(i);
                if (separators.contains(first)) {
                    String concat = "" + first;
                    nextWordOrSeparator = nextWordOrSeparator.concat(concat);
                }
                i++;
            }
        }
        return nextWordOrSeparator;
    }

    /**
     * input one dictionary and find the words.
     *
     * @param wordsMap
     *            Map of all words and their counts.
     * @param ci
     * @param words
     *            Queue containing all words in the .txt file.
     * @param fileOutput
     *            Output stream to a specific file location.
     * @updates words
     * @requires <pre>
     * input.is_open and
     *
     * </pre>
     * @ensures <pre>
     * input.is_open and
     * #input.content = [one word from the list
     * print out correct html format
     * </pre>
     */
    public static void wordSort(Queue<String> words,
            Map<String, Integer> wordsMap, Comparator<String> ci,
            SimpleWriter fileOutput) {
        while (words.length() != 0) {
            String word = words.dequeue();
            if (!wordsMap.hasKey(word)) {
                wordsMap.add(word, 1);
            } else {
                int oldValue = wordsMap.value(word);
                int newValue = oldValue + 1;
                wordsMap.replaceValue(word, newValue);
            }
        }
        Map<String, Integer> tempMap = wordsMap.newInstance();
        Queue<String> tempWords = words.newInstance();

        while (wordsMap.iterator().hasNext()) {
            Pair<String, Integer> tempPair = wordsMap.removeAny();
            tempMap.add(tempPair.key(), tempPair.value());
            tempWords.enqueue(tempPair.key());
        }
        wordsMap.clear();
        tempWords.sort(ci);
        while (tempWords.iterator().hasNext()) {
            String word = tempWords.dequeue();
            Pair<String, Integer> orderedDictionary = tempMap.remove(word);
            fileOutput.println("<tr>");
            fileOutput.println("<td>" + orderedDictionary.key() + "</td>");
            fileOutput.println("<td>" + orderedDictionary.value() + "</td>");
            fileOutput.println("</tr>");
        }
    }

    /**
     * Main method.
     *
     * @param args
     *            the command line arguments; unused here
     */
    public static void main(String[] args) {
        final String separatorStr = " \t, -- .";
        Set<Character> separatorSet = new Set1L<>();
        generateElements(separatorStr, separatorSet);

        SimpleWriter out = new SimpleWriter1L();
        out.println("Enter a filename:");
        SimpleReader in = new SimpleReader1L();
        String fileName = in.nextLine();
        SimpleReader fileReader = new SimpleReader1L(fileName);

        out.println("Enter an output location:");
        String location = in.nextLine();
        SimpleWriter fileOutput = new SimpleWriter1L(
                location + "/wordsCounted.html");

        Map<String, Integer> wordMap = new Map1L<>();
        Queue<String> words = new Queue1L<>();

        while (!fileReader.atEOS()) {
            String line = fileReader.nextLine();
            int position = 0;
            while (position < line.length()) {
                String word = nextWordOrSeparator(line, position, separatorSet);
                if (!separatorSet.contains(word.charAt(0))) {
                    words.enqueue(word);
                }
                position = position + word.length();
            }
        }

        // Sorts the words in alphabetical order
        Comparator<String> alphabetical = new Compare();
        words.sort(alphabetical);

        outputIndexHeader(fileOutput, fileName);
        wordSort(words, wordMap, alphabetical, fileOutput);
        outputIndexFooter(fileOutput);

        in.close();
        out.close();
        fileReader.close();
        fileOutput.close();
    }

}
